import { Injectable, Logger, BadRequestException, NotFoundException } from '@nestjs/common';
import { DatabaseService } from 'src/database/database.service';
import { Prisma } from '@prisma/client';

@Injectable()
export class SkuService {
  private readonly logger = new Logger(SkuService.name);

  constructor(private readonly databaseService: DatabaseService) {}

  /**
   * 创建SKU规格模板
   */
  async createSpecTemplate(createSpecTemplateDto: {
    name: string;
    description?: string;
    specs: Array<{
      specName: string;
      specValues: string[];
      sort?: number;
    }>;
    shopId?: number;
  }) {
    try {
      const template = await this.databaseService.productSpecTemplate.create({
        data: {
          name: createSpecTemplateDto.name,
          description: createSpecTemplateDto.description,
          shopId: createSpecTemplateDto.shopId || 1,
          templateSpecs: {
            create: createSpecTemplateDto.specs.map((spec, index) => ({
              specName: spec.specName,
              specValues: spec.specValues,
              sort: spec.sort || index,
            })),
          },
        },
        include: {
          templateSpecs: {
            orderBy: { sort: 'asc' },
          },
        },
      });

      this.logger.log(`SKU规格模板创建成功: ${template.templateId}`);
      return template;
    } catch (error) {
      this.logger.error(`创建SKU规格模板失败: ${error.message}`, error.stack);
      throw new BadRequestException('创建SKU规格模板失败');
    }
  }

  /**
   * 获取SKU规格模板列表
   */
  async getSpecTemplates(queryDto: {
    page?: number;
    size?: number;
    shopId?: number;
    keyword?: string;
  }) {
    const { page = 1, size = 20, shopId, keyword } = queryDto;
    const skip = (page - 1) * size;

    const where: Prisma.ProductSpecTemplateWhereInput = {
      ...(shopId !== undefined && { shopId }),
      ...(keyword && {
        OR: [
          { name: { contains: keyword, mode: 'insensitive' } },
          { description: { contains: keyword, mode: 'insensitive' } },
        ],
      }),
    };

    const [templates, total] = await Promise.all([
      this.databaseService.productSpecTemplate.findMany({
        skip,
        take: size,
        where,
        orderBy: { createdAt: 'desc' },
        include: {
          templateSpecs: {
            orderBy: { sort: 'asc' },
          },
        },
      }),
      this.databaseService.productSpecTemplate.count({ where }),
    ]);

    return {
      records: templates,
      total,
      page,
      size,
      totalPages: Math.ceil(total / size),
    };
  }

  /**
   * 根据模板生成SKU组合
   */
  async generateSkusFromTemplate(templateId: number, productId: number, skuData: {
    basePrice: number;
    priceAdjustments?: Array<{
      specName: string;
      specValue: string;
      adjustment: number;
    }>;
    baseStock?: number;
    stockAllocation?: Array<{
      sku: string;
      stock: number;
    }>;
    generateSkus?: boolean;
  }) {
    try {
      const template = await this.databaseService.productSpecTemplate.findUnique({
        where: { templateId },
        include: {
          templateSpecs: {
            orderBy: { sort: 'asc' },
          },
        },
      });

      if (!template) {
        throw new NotFoundException('SKU规格模板不存在');
      }

      const product = await this.databaseService.product.findUnique({
        where: { productId },
      });

      if (!product) {
        throw new NotFoundException('商品不存在');
      }

      // 生成所有可能的SKU组合
      const skuCombinations = this.generateSkuCombinations(template.templateSpecs);

      const createdSpecs = [];
      let totalStock = 0;

      for (const combination of skuCombinations) {
        const sku = this.generateSkuCode(productId, combination);
        const specPrice = this.calculateSpecPrice(skuData.basePrice, combination, skuData.priceAdjustments);
        const specStock = this.getSpecStock(sku, skuData.baseStock, skuData.stockAllocation);

        if (skuData.generateSkus !== false) {
          const spec = await this.databaseService.productSpec.create({
            data: {
              productId,
              specName: combination.map(c => `${c.specName}:${c.specValue}`).join(';'),
              specValue: combination.map(c => c.specValue).join(';'),
              specPrice,
              specStock,
              specSku: sku,
              sort: createdSpecs.length,
            },
          });

          createdSpecs.push(spec);
          totalStock += specStock;
        }
      }

      // 更新商品为多规格类型
      await this.databaseService.product.update({
        where: { productId },
        data: {
          specType: 1,
          stock: totalStock,
        },
      });

      this.logger.log(`SKU生成成功: ${productId}, 共生成${createdSpecs.length}个SKU`);
      return {
        productId,
        skuCount: createdSpecs.length,
        totalStock,
        specs: createdSpecs,
      };
    } catch (error) {
      this.logger.error(`生成SKU失败: ${error.message}`, error.stack);
      throw new BadRequestException('生成SKU失败');
    }
  }

  /**
   * 批量更新SKU价格
   */
  async batchUpdatePrices(productId: number, priceUpdates: Array<{
    specId: number;
    price: number;
  }>) {
    try {
      const updatePromises = priceUpdates.map(update =>
        this.databaseService.productSpec.update({
          where: {
            specId: update.specId,
            productId, // 确保只能更新该商品的SKU
          },
          data: { specPrice: update.price },
        })
      );

      await this.databaseService.$transaction(updatePromises);

      // 更新商品最低价格
      const minPriceSpec = await this.databaseService.productSpec.findFirst({
        where: { productId },
        orderBy: { specPrice: 'asc' },
      });

      if (minPriceSpec) {
        await this.databaseService.product.update({
          where: { productId },
          data: { price: minPriceSpec.specPrice },
        });
      }

      this.logger.log(`SKU价格批量更新成功: ${productId}, 共更新${priceUpdates.length}个SKU`);
      return { message: 'SKU价格批量更新成功' };
    } catch (error) {
      this.logger.error(`批量更新SKU价格失败: ${error.message}`, error.stack);
      throw new BadRequestException('批量更新SKU价格失败');
    }
  }

  /**
   * 批量更新SKU库存
   */
  async batchUpdateStock(productId: number, stockUpdates: Array<{
    specId: number;
    stock: number;
    operation?: 'set' | 'add' | 'subtract';
  }>) {
    try {
      const updatePromises = stockUpdates.map(async update => {
        const currentSpec = await this.databaseService.productSpec.findUnique({
          where: { specId: update.specId },
        });

        if (!currentSpec || currentSpec.productId !== productId) {
          throw new BadRequestException(`SKU ${update.specId} 不存在或不属于该商品`);
        }

        let newStock = update.stock;
        if (update.operation === 'add') {
          newStock = currentSpec.specStock + update.stock;
        } else if (update.operation === 'subtract') {
          newStock = currentSpec.specStock - update.stock;
          if (newStock < 0) {
            throw new BadRequestException(`SKU ${update.specId} 库存不足`);
          }
        }

        return this.databaseService.productSpec.update({
          where: { specId: update.specId },
          data: { specStock: newStock },
        });
      });

      await this.databaseService.$transaction(updatePromises);

      // 更新商品总库存
      const totalStock = await this.databaseService.productSpec.aggregate({
        where: { productId },
        _sum: { specStock: true },
      });

      await this.databaseService.product.update({
        where: { productId },
        data: { stock: totalStock._sum.specStock || 0 },
      });

      this.logger.log(`SKU库存批量更新成功: ${productId}, 共更新${stockUpdates.length}个SKU`);
      return { message: 'SKU库存批量更新成功' };
    } catch (error) {
      this.logger.error(`批量更新SKU库存失败: ${error.message}`, error.stack);
      throw new BadRequestException('批量更新SKU库存失败');
    }
  }

  /**
   * 获取SKU库存详情
   */
  async getSkuStockDetails(productId: number) {
    try {
      const specs = await this.databaseService.productSpec.findMany({
        where: { productId },
        orderBy: { sort: 'asc' },
      });

      const totalStock = specs.reduce((sum, spec) => sum + spec.specStock, 0);
      const minPrice = Math.min(...specs.map(spec => spec.specPrice || Infinity));

      return {
        productId,
        totalStock,
        minPrice,
        skuCount: specs.length,
        specs: specs.map(spec => ({
          specId: spec.specId,
          specName: spec.specName,
          specValue: spec.specValue,
          specSku: spec.specSku,
          specPrice: spec.specPrice,
          specStock: spec.specStock,
          specImage: spec.specImage,
        })),
      };
    } catch (error) {
      this.logger.error(`获取SKU库存详情失败: ${error.message}`, error.stack);
      throw new BadRequestException('获取SKU库存详情失败');
    }
  }

  /**
   * SKU库存预警
   */
  async getLowStockSkus(shopId?: number, threshold = 10) {
    try {
      const where: Prisma.ProductSpecWhereInput = {
        specStock: { lte: threshold },
        ...(shopId !== undefined && {
          Product: {
            shopId,
          },
        }),
      };

      const lowStockSpecs = await this.databaseService.productSpec.findMany({
        where,
        include: {
          Product: {
            select: {
              productId: true,
              name: true,
              shopId: true,
            },
          },
        },
        orderBy: { specStock: 'asc' },
      });

      return {
        threshold,
        count: lowStockSpecs.length,
        specs: lowStockSpecs,
      };
    } catch (error) {
      this.logger.error(`获取低库存SKU失败: ${error.message}`, error.stack);
      throw new BadRequestException('获取低库存SKU失败');
    }
  }

  /**
   * 生成SKU组合
   */
  private generateSkuCombinations(templateSpecs: any[]): any[] {
    if (templateSpecs.length === 0) return [];

    const combinations: any[] = [];
    const generate = (current: any[], remaining: any[][]) => {
      if (remaining.length === 0) {
        combinations.push(current);
        return;
      }

      const [currentSpec, ...restSpecs] = remaining;
      for (const value of currentSpec.specValues) {
        generate([...current, { specName: currentSpec.specName, specValue: value }], restSpecs);
      }
    };

    const specArray = templateSpecs.map(spec => ({
      specName: spec.specName,
      specValues: spec.specValues,
    }));

    generate([], specArray);
    return combinations;
  }

  /**
   * 生成SKU编码
   */
  private generateSkuCode(productId: number, combination: any[]): string {
    const prefix = `SKU${productId}`;
    const suffix = combination.map(c =>
      c.specValue.replace(/[^a-zA-Z0-9]/g, '').substring(0, 3)
    ).join('');
    const timestamp = Date.now().toString().slice(-4);
    return `${prefix}_${suffix}_${timestamp}`;
  }

  /**
   * 计算SKU价格
   */
  private calculateSpecPrice(basePrice: number, combination: any[], adjustments?: any[]): number {
    let price = basePrice;

    if (adjustments) {
      for (const adjustment of adjustments) {
        const hasMatch = combination.some(c =>
          c.specName === adjustment.specName && c.specValue === adjustment.specValue
        );
        if (hasMatch) {
          price += adjustment.adjustment;
        }
      }
    }

    return Math.max(0, price);
  }

  /**
   * 获取SKU库存
   */
  private getSpecStock(sku: string, baseStock?: number, stockAllocation?: any[]): number {
    if (stockAllocation) {
      const allocation = stockAllocation.find(a => a.sku === sku);
      return allocation ? allocation.stock : (baseStock || 0);
    }
    return baseStock || 0;
  }
}